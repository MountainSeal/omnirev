{-# LANGUAGE ApplicativeDo   #-}
{-# LANGUAGE RecordWildCards #-}
-- automatically generated by BNF Converter
module Main where


import System.IO ( stdin, hGetContents, hSetBuffering, stdin, stdout, BufferMode (NoBuffering) )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess, ExitCode (ExitFailure) )
import Control.Monad (when)
import Options.Applicative
import Data.Semigroup ((<>))

import Omnirev.LexOmnirev
import Omnirev.ParOmnirev
import Omnirev.PrintOmnirev
import Omnirev.AbsOmnirev
import Omnirev.CheckOmnirev
import Omnirev.EvalOmnirev




import Omnirev.ErrM
import Control.Monad.Writer.Strict
import qualified Data.Map as M
import Data.List (intercalate)

type ParseFun a = [Token] -> Err a

myLLexer = myLexer

runCompile :: ParseFun Program -> Bool -> Bool -> Bool -> String -> IO ()
runCompile prog cflg eflg lflg src = do
  let ts = myLLexer src
  case prog ts of
    Bad s -> do
      if lflg then do
        putStrLn "\nParse              Failed...\n"
        putStrLn "Tokens:"
        print ts
        putStrLn s
      else pure ()
      exitFailure
    Ok tree -> do
      if lflg then do
        putStrLn "\nParse Successful!"
        showTree tree
      else pure ()
      if not cflg then exitSuccess
      else case check tree of
        Bad s -> do
          if lflg then do
            putStrLn s
            putStrLn "\nType Check         Failed...\n"
          else pure ()
          exitFailure
        Ok (env, clog) -> do
          if lflg then do
            putStrLn "\nCheck Successful!"
            putStrLn $ unlines clog
          else pure ()
          if not eflg then exitSuccess
          else case eval env of
            Bad err -> do
              if lflg then do
                putStrLn err
                putStrLn "\nEval               Failed...\n"
              else pure ()
              exitFailure
            Ok (res,elog) -> do
              if lflg then do
                putStrLn "\nEval Successful!"
                putStrLn $ unlines elog
              else pure ()
              putStrLn $ unlines $ map (\(i,tm) -> printTree i ++ " = " ++ printTree tm) res
              exitSuccess

showTree :: (Show a, Print a) => a -> IO ()
showTree tree
 = do
      putStrLn $ "\n[Abstract Syntax]\n\n" ++ show tree
      putStrLn $ "\n[Linearized tree]\n\n" ++ printTree tree

main :: IO ()
main = pas =<< execParser opts
  where
    opts = info (args <**> helper) -- 常にヘルプ文出す場合はhelper使う
      (  fullDesc
      <> header "omnirev - interpreter for omnirev"
      )

pas :: Args -> IO ()
pas Version = exitFailure
pas (Source cflg eflg lflg Nothing) = getContents >>= runCompile pProgram cflg eflg lflg
pas (Source cflg eflg lflg (Just path)) = do
  if lflg then putStrLn path else pure ()
  src <- readFile path
  runCompile pProgram cflg eflg lflg src

data Args
  = Version
  | Source
  { fcheck :: Bool
  , feval :: Bool
  , flog :: Bool
  , path :: Maybe FilePath
  }
  deriving (Read, Show)

source :: Parser Args
source = do
  fcheck <- switch
    ( help "Check type of files"
   <> long "check"
   <> short 'c' )
  feval <- switch
    ( help "Evaluate program of files"
   <> long "eval"
   <> short 'e' )
  flog <- switch
    ( help "Print log"
   <> long "log"
   <> short 'l' )
  path <- optional $ strOption
    ( help "file path"
   <> short 'f'
   <> metavar "<filepath>" )
  pure Source {..}

version :: Parser Args
version = do
  infoOption "0.5.0"
    ( help "Show version"
   <> long "version"
   <> short 'v' )
  pure Version

args :: Parser Args
args = source <|> version