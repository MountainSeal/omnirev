-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Omnirev.ParOmnirev where
import Omnirev.AbsOmnirev as AbsOmnirev
import Omnirev.LexOmnirev
import Omnirev.ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  '()' { PT _ (TS _ 2) }
  '(*)' { PT _ (TS _ 3) }
  '(+)' { PT _ (TS _ 4) }
  ')' { PT _ (TS _ 5) }
  '*' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '.' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '=' { PT _ (TS _ 11) }
  'I' { PT _ (TS _ 12) }
  'fix' { PT _ (TS _ 13) }
  'fold' { PT _ (TS _ 14) }
  'inl' { PT _ (TS _ 15) }
  'inr' { PT _ (TS _ 16) }
  'measure' { PT _ (TS _ 17) }
  'term' { PT _ (TS _ 18) }
  'type' { PT _ (TS _ 19) }
  '|' { PT _ (TS _ 20) }
  '||' { PT _ (TS _ 21) }
  '~' { PT _ (TS _ 22) }
  '~>' { PT _ (TS _ 23) }

L_ident  { PT _ (TV $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }

Program :: { Program }
Program : ListDef { AbsOmnirev.Prog $1 }
Def :: { Def }
Def : 'type' Ident '=' Type { AbsOmnirev.DType $2 $4 }
    | 'term' Ident ':' Type '=' Term { AbsOmnirev.DTerm $2 $4 $6 }
ListDef :: { [Def] }
ListDef : Def { (:[]) $1 } | Def ListDef { (:) $1 $2 }
Type5 :: { Type }
Type5 : Ident { AbsOmnirev.TVar $1 }
      | 'I' { AbsOmnirev.TUnit }
      | 'fix' Ident '.' Type5 { AbsOmnirev.TInd $2 $4 }
      | '(' Type ')' { $2 }
Type3 :: { Type }
Type3 : Type3 '(+)' Type4 { AbsOmnirev.TSum $1 $3 } | Type4 { $1 }
Type4 :: { Type }
Type4 : Type4 '(*)' Type5 { AbsOmnirev.TTensor $1 $3 }
      | Type5 { $1 }
Type1 :: { Type }
Type1 : Type1 '||' Type2 { AbsOmnirev.TPar $1 $3 } | Type2 { $1 }
Type2 :: { Type }
Type2 : Type2 '~>' Type3 { AbsOmnirev.TFunc $1 $3 } | Type3 { $1 }
Type :: { Type }
Type : Type1 { $1 }
Value4 :: { Value }
Value4 : Ident { AbsOmnirev.VVar $1 }
       | '()' { AbsOmnirev.VUnit }
       | 'inl' Value4 { AbsOmnirev.VLeft $2 }
       | 'inr' Value4 { AbsOmnirev.VRight $2 }
       | 'fold' Value4 { AbsOmnirev.VFold $2 }
       | '(' Value ')' { $2 }
Value3 :: { Value }
Value3 : Value3 '*' Value4 { AbsOmnirev.VTensor $1 $3 }
       | Value4 { $1 }
Value1 :: { Value }
Value1 : Value1 '|' Value2 { AbsOmnirev.VPar $1 $3 }
       | Value2 { $1 }
Value2 :: { Value }
Value2 : Value2 '->' Value3 { AbsOmnirev.VArrow $1 $3 }
       | Value3 { $1 }
Value :: { Value }
Value : Value1 { $1 }
Term3 :: { Term }
Term3 : Value { AbsOmnirev.TmVal $1 }
      | '~' Term3 { AbsOmnirev.TmTrans $2 }
      | 'measure' Term3 { AbsOmnirev.TmMeas $2 }
      | '(' Term ')' { $2 }
Term2 :: { Term }
Term2 : Term2 Term3 { AbsOmnirev.TmApp $1 $2 } | Term3 { $1 }
Term1 :: { Term }
Term1 : Term1 ';' Term2 { AbsOmnirev.TmComp $1 $3 } | Term2 { $1 }
Term :: { Term }
Term : Term1 { $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

